<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Sankey Diagram</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://npmcdn.com/d3-sankey@0.12.0/dist/d3-sankey.js"></script>
    <style>
        #container {
            overflow: scroll;
            width: 100%;
            height: 600px;
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <select id="colorSelect">
        <option value="input">Color by input</option>
        <option value="output">Color by output</option>
        <option value="path" selected>Color by input-output</option>
    </select>
    <div id="container">
        <svg id="chart" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>
    <script>
       const margin = { top: 20, right: 20, bottom: 20, left: 20 };
const svgWidth = 5000;
const svgHeight = 1000;
const width = 1200 - margin.left - margin.right;
const height = 600 - margin.top - margin.bottom;
let edgeColor = 'path' 
        const svg = d3.select('#chart')
            .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`)
            .style("width", "100%")
            .style("height", "100%")
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const select = document.querySelector('#colorSelect');
        select.onchange = () => {
            edgeColor = select.value;
            update();
        };

        // Adding zoom and pan behavior
        const zoom = d3.zoom()
            .scaleExtent([1, 10])
            .on("zoom", function (event) {
                svg.attr("transform", event.transform);
            });
        d3.select('#chart').call(zoom);

        const f = d3.format(",.0f");
        const format = d => `${f(d)} TWh`;

        // Define a color scale for target colors
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
        // Define a color scale for target colors
    

        const data = {
            nodes: [],
            links: [],
        };

        // Your data format
        const inputData = [
 {
                "source": "Russia 1860",
                "target": "Modernism 1898",
                "sourcecolor": "Russia",
                "targetcolor": "Russia",
                "linklabel": "Chekhov",
                "sourceyear": 1860,
                "targetyear": 1898,
                "value": 1
            },

  {
    "source": "Modernism 1898",
    "target": "Modernism 1905",
    "sourcecolor": "Russia",
    "targetcolor": "Russia",
    "linklabel": "Chekhov",
    "sourceyear": 1898,
    "targetyear": 1905,
    "value": 1
  },
  {
    "source": "Modernism 1898",
    "target": "Modernism 1905",
    "sourcecolor": "Russia",
    "targetcolor": "Russia",
    "linklabel": "Diaghilev",
    "sourceyear": 1898,
    "targetyear": 1905,
    "value": 1
  },
  {
    "source": "Russia 1872",
    "target": "Modernism 1898",
    "sourcecolor": "Russia",
    "targetcolor": "Russia",
    "linklabel": "Diaghilev",
    "sourceyear": 1872,
    "targetyear": 1898,
    "value": 1
  },
  {
    "source": "Modernism 1905",
    "target": "Paris 1930s",
    "sourcecolor": "Russia",
    "targetcolor": "Paris",
    "linklabel": "Diaghilev",
    "sourceyear": 1905,
    "targetyear": 1930,
    "value": 1
  },
  {
    "source": "Kherson 1881",
    "target": "Avant Garde 1915",
    "sourcecolor": "Ukraine",
    "targetcolor": "Russia",
    "linklabel": "Larionov",
    "sourceyear": 1881,
    "targetyear": 1915,
    "value": 1
  },
  {
    "source": "Russia 1881",
    "target": "Avant Garde 1915",
    "sourcecolor": "Russia",
    "targetcolor": "Russia",
    "linklabel": "Natalia Goncharova",
    "sourceyear": 1881,
    "targetyear": 1915,
    "value": 1
  },
  {
    "source": "Russia 1889",
    "target": "Avant Garde 1915",
    "sourcecolor": "Russia",
    "targetcolor": "Russia",
    "linklabel": "Liubov Popova",
    "sourceyear": 1889,
    "targetyear": 1915,
    "value": 1
  },
  {
    "source": "Belarus 1887",
    "target": "Avant Garde 1915",
    "sourcecolor": "Belarus",
    "targetcolor": "Russia",
    "linklabel": "Chagall",
    "sourceyear": 1887,
    "targetyear": 1915,
    "value": 1
  },
  {
    "source": "Kyiv 1879",
    "target": "Avant Garde 1915",
    "sourcecolor": "Ukraine",
    "targetcolor": "Russia",
    "linklabel": "Malevich",
    "sourceyear": 1879,
    "targetyear": 1915,
    "value": 1
  }
];

        // Process data and add nodes
        const nodeMap = new Map();
        inputData.forEach(d => {
            if (!nodeMap.has(d.source)) {
                nodeMap.set(d.source, { id: d.source, year: d.sourceyear, targetcolor: d.sourcecolor, linklabel: d.linklabel });
            }
            if (!nodeMap.has(d.target)) {
                nodeMap.set(d.target, { id: d.target, year: d.targetyear, targetcolor: d.targetcolor, linklabel: d.linklabel });
            }
        });

        data.nodes = Array.from(nodeMap.values());

        // Find the earliest and latest year
        const minYear = d3.min(data.nodes, d => d.year);
        const maxYear = d3.max(data.nodes, d => d.year);

        // Calculate x-position for nodes based on their years
        const xScale = d3.scaleLinear()
            .domain([minYear, maxYear])
            .range([0, width]);

        // Create a mapping between "linklabel" and y-positions
        const labelYPositions = {};
        let yPosition = 0; // Initial y-position

        data.nodes.forEach(d => {
            d.x = xScale(d.year);

            const linkLabel = d.linklabel;
            if (!labelYPositions[linkLabel]) {
                labelYPositions[linkLabel] = yPosition;
                yPosition += 20; // Adjust the value to control vertical spacing
            }

            d.y = labelYPositions[linkLabel];
        });

        // Initialize the Sankey diagram
        const sankey = d3.sankey()
            .nodeWidth(15)
            .nodePadding(10)
            .extent([[1, 5], [width - 1, height - 5]])
            .nodeId(d => d.id);

        // Add links
        inputData.forEach(d => {
            data.links.push({
                source: d.source,
                target: d.target,
                sourcecolor: d.sourcecolor,
                targetcolor: d.targetcolor,
                linklabel: d.linklabel,
                sourceyear: d.sourceyear,
                targetyear: d.targetyear,
                value: d.value,
            });
        });

        // Compute nodes and links
        const { nodes, links } = sankey(data);

        // Function to prevent label overlap
        function avoidLabelOverlap(labelNodes) {
            const padding = 5;
            const sortedNodes = labelNodes.sort((a, b) => a.y - b.y);

            for (let i = 1; i < sortedNodes.length; i++) {
                const prevNode = sortedNodes[i - 1];
                const currNode = sortedNodes[i];

                if (currNode.y - prevNode.y < padding) {
                    currNode.y = prevNode.y + padding;
                }
            }
        }

        // Update the diagram
        function update() {
            if (edgeColor === "path") {
                const gradient = svg.append("defs")
                    .selectAll("linearGradient")
                    .data(links)
                    .enter().append("linearGradient")
                    .attr("id", (d, i) => `link-${d.source.index}-${d.target.index}`)
                    .attr("gradientUnits", "userSpaceOnUse")
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                gradient.append("stop")
                    .attr("offset", "0%")
                    .attr("stop-color", d => colorScale(d.source.targetcolor));

                gradient.append("stop")
                    .attr("offset", "100%")
                    .attr("stop-color", d => colorScale(d.target.targetcolor));
            }

            // Create links
            const link = svg.append("g")
                .attr("fill", "none")
                .attr("stroke-opacity", 0.5)
                .selectAll("g")
                .data(links)
                .enter().append("g")
                .style("mix-blend-mode", "multiply");

            link.append("path")
                .attr("stroke", d => edgeColor === "path" ? `url(#link-${d.source.index}-${d.target.index})`
                    : edgeColor === "input" ? colorScale(d.source.targetcolor)
                    : colorScale(d.target.targetcolor))
                .attr("stroke-width", d => Math.max(1, d.width))
                .attr("d", d => {
                    const x0 = d.source.x;
                    const x1 = d.target.x;
                    const y0 = (d.y0 + d.y1) / 2;
                    return `M${x0},${y0}C${(x0 + x1) / 2},${y0} ${(x0 + x1) / 2},${d.y1} ${x1},${d.y1}`;
                });

            link.append("text")
                .attr("x", d => (d.source.x + d.target.x) / 2)
                .attr("y", d => (d.y1 + d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "middle")
                .style("fill", "black")
                .style("font-size", "10px")
                .text(d => `${d.linklabel}`);

            // Create nodes
            svg.append("g")
                .attr("stroke", "#000")
                .selectAll("rect")
                .data(nodes)
                .enter().append("rect")
                .attr("x", d => d.x)
                .attr("y", d => d.y0)
                .attr("height", d => d.y1 - d.y0)
                .attr("width", d => Math.max(0, d.x1 - d.x0))
                .attr("fill", d => colorScale(d.targetcolor)); // Use the color scale

            // Add labels to the nodes
            const labelNodes = svg.append("g")
                .style("font", "10px sans-serif")
                .selectAll("text")
                .data(nodes)
                .enter().append("text")
                .attr("x", d => d.x + 30)
                .attr("y", d => (d.y1 + d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "middle")
                .style("fill", "black")
                .style("font-size", "10px")
                .text(d => d.id);

            avoidLabelOverlap(labelNodes);
        }

        update();
    </script>
</body>
</html>
